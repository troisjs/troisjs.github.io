# Core Concepts

## `TroisCanvas`
A Trois app needs to be wrapped in a `TroisCanvas` component:

```html
<TroisCanvas>
    <!-- Your code -->
</TroisCanvas>
```

In a .vue [single file component](https://v3.vuejs.org/guide/single-file-component.html#single-file-components), this will be inside the `<template>` tag.

## Three.js and Trois

Most Trois concepts are direct translations of Three.js concepts - let's look at [meshes](https://threejs.org/docs/index.html?q=mesh#api/en/objects/Mesh) as an example.

A standard Three.js mesh requires a geometry and a material. Three.js code to create and add a yellow cube to the scene might look like [this](https://threejs.org/docs/index.html?q=mesh#api/en/objects/Mesh):

```js
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
```

In Trois, this produces the same result:

```html
<TroisCanvas>
    <mesh>
        <boxGeometry :args="[1, 1 ,1]"/>
        <meshBasicMaterial :color="0xffff00"/>
    </mesh>
</TroisCanvas>
```

A few points to note:

* Trois component names match class names in Three.js. 
```
// three.js
new THREE.Mesh()

<!-- trois -->
<mesh/>

// three.js
new THREE.BoxGeometry()

<!-- trois -->
<boxGeometry/>
```
* Every component can accept an `args` prop that take an array of arguments to pass to class constructors. This in Three.js:
    
```js
new THREE.BoxGeometry(1, 2, 3)
```

would map to this in Trois:

```html
<boxGeometry :args="[1, 2, 3]"/>
```

* Any property you can add to a Three.js object (for example, the `color` property of a `MeshBasicMaterial`) can be added as a reactive prop on a Trois component:

```js
const material = new THREE.MeshBasicMaterial()
material.color = 0xffff00
```

would map to this in Trois:

```html
<meshBasicMaterial :color="0xffff00"/>
```

* You can set a property that would normally use dot notation with a dash in the prop name. For example, this in Three.js:

```js
const mesh = new THREE.Mesh()
mesh.position.z = 5
```

would map to this in Trois:

```html
<mesh :position-z="5"/>
```

## Components

You can use most Three.js classes in Trois, such as:

* `Group`
* `Mesh`
* Geometries (box, icosahedron, plane, etc)
* Materials (standard, basic, points, shader, etc)
* Lights (spotlights, point lights, directional, etc)

For a full list, see the `autoGeneratedComponents` list in the [source code](https://github.com/troisjs/renderer-proof-of-concept/blob/main/src/renderer/components/components.ts).

To add any features not in that list, see the instructions under [Extend](/renderer/extend).

## Hierarchy

Items that inherit from [THREE.Object3D](https://threejs.org/docs/index.html?q=mesh#api/en/core/Object3D) will follow the hierarchy of your Trois template. For example, this Trois code:

```html
<!-- 1 -->
<group>
    <!-- 2 -->
    <mesh/>

    <!-- 3 -->
    <mesh>
        <!-- 4 -->
        <mesh/>
    </mesh>
</group>
```

would create:

* A `Group` (1) with two direct children (2 and 3)
* A `Mesh` (2) with no children
* Another `Mesh` (3) with one child (4)
* Another `Mesh` (4) with no children

Just like with Three.js, any transform changes you apply to a parent element will be applied to the children as well. Changing the `group`'s `position-x` value would move all four objects as a single unit.

## `attach`

There are several classes in Three.js that do not inherit from `Object3D` that you'll use in your scenes. You can access instances of those classes with the `attach` property.

For example, meshes usually require a geometry and a material:

```html
<mesh>
    <boxGeometry />
    <meshBasicMaterial />
</mesh>
```

But how does the mesh know to use the `boxGeometry` as the geometry and the `meshBasicMaterial` as the material? Behind the scenes, Trois treats the above code like this:

```html
<mesh :args="['$attached.geometry', '$attached.material']">
    <boxGeometry attach="geometry"/>
    <meshBasicMaterial attach="material" />
</mesh>
```

and takes the following steps:

1. A `new THREE.BoxGeometry()` is created. 
2. Trois registers the `attach` prop on the component, with a value set to `geometry`. As a result, it attaches the newly-created geometry to a property called `$attached.geometry` on its parent.
3. A `new THREE.MeshBasicMaterial()` is created.
4. Trois attaches the new material to its parent's `$attached.material` property.
5. A `new THREE.Mesh` is created. Trois uses the array in the `args` property as the arguments for the function, so the full function reads: `new THREE.Mesh('$attached.geometry', '$attached.material')`.
6. Trois automatically replaces the `$attached` values with the matching `attach` children. The `$attached.geometry` becomes the `new THREE.BoxGeometry` from step 1, and the `$attached.material` becomes the `new THREE.MeshBasicMaterial` from step 3.

Geometries and materials are so commonly used that Trois handles the attachment automatically, but you can specify 

## `instance`

TODO